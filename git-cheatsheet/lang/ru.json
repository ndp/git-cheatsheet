{
    "dir": "ltr",
    "author": "Vitaliy Star",
    "commands": {
        "status": {
            "cmd": "status",
            "docs": "Отобразить: \r• пути, которые имеют различия между индексным файлом и текущим коммитом `HEAD`, \r• пути, которые имеют различия между рабочей областью и индексным файлом, и \r• пути в рабочей области, которые не отслеживаются git."
        },
        "diff": {
            "cmd": "diff",
            "docs": "Отобразить различия, не добавленные в индекс."
        },
        "diff x": {
            "cmd": "diff <коммит или ветка>",
            "docs": "Просмотреть изменения, которые есть в вашей рабочей области относительно именованного <коммита>. Вы можете использовать HEAD, чтобы сравнить его с последним коммитом, или имя ветки, чтобы сравнить его с концом другой ветки."
        },
        "add x": {
            "cmd": "add <файл... или каталог...>",
            "docs": "Добавить текущее содержимое новых или изменённых файлов в индекс, тем самым подготавливая это содержимое для включения в следующий коммит. Используйте `add --interactive`, чтобы интерактивно добавить изменённое содержимое рабочей области в индекс."
        },
        "add -u": {
            "cmd": "add -u",
            "docs": "Добавить в индекс текущее содержимое изменённых (НЕ НОВЫХ) файлов. Это похоже на то, что делает git commit -a при подготовке к коммиту."
        },
        "rm x": {
            "cmd": "rm <файл(ы)...>",
            "docs": "Удалить файл(ы) из рабочей области и индекса."
        },
        "mv x": {
            "cmd": "mv <файл(ы)...>",
            "docs": "Переместить файл(ы) в рабочую область и в индекс."
        },
        "commit -a": {
            "cmd": "commit -a [-m 'сообщение']",
            "docs": "Закоммитить все файлы, изменённые с момента последнего коммита, за исключением неотслеживаемых файлов (т.е. всех файлов, которые уже указаны в индексе). Удаляет файлы в индексе, которые были удалены из рабочей области."
        },
        "checkout x": {
            "cmd": "checkout <файл(ы)... или каталог>",
            "docs": "Обновить файл или каталог в рабочей области. НЕ переключает ветки."
        },
        "reset head x": {
            "cmd": "reset HEAD <файл(ы)...>",
            "docs": "Удалить указанные файлы из следующего коммита. Сбрасывает индекс, но не рабочее дерево (т. е. измененные файлы сохраняются, но не помечаются для фиксации) и сообщает, что не было обновлено."
        },
        "reset --soft head^": {
            "cmd": "reset --soft HEAD^",
            "docs": "Отменить последний коммит, оставив его изменения в рабочей области незафиксированными. Не затрагивает индексный файл или рабочее дерево. Единственное изменение, которое он вносит, — это заголовок локального репозитория."
        },
        "reset --hard": {
            "cmd": "reset --hard",
            "docs": "Сопоставить рабочую область и индекс с локальным деревом. ВНИМАНИЕ: Любые изменения в отслеживаемых файлах в рабочем дереве с момента фиксации теряются. Используйте это, если слияние привело к конфликтам и вы хотите начать все сначала. Укажите `ORIG_HEAD`, чтобы отменить последнее успешное слияние и любые последующие изменения."
        },
        "switch": {
            "cmd": "switch <ветка>",
            "docs": "Переключить ветку, обновляя индекс и рабочую область, чтобы они отражали указанную <ветку>, и обновляя `HEAD` до <ветки>."
        },
        "checkout -b x": {
            "cmd": "checkout -b <название новой ветки>",
            "docs": "Создать ветку и переключить на неё."
        },
        "merge x": {
            "cmd": "merge <коммит или ветку>",
            "docs": "Объединить изменения из <имя ветки> в текущую ветку.\rИспользуйте `‑‑no-commit`, чтобы оставить изменения незакоммиченными. Используйте `--no-ff` для создания коммита слияния, даже если слияние разрешается как ускоренная перемотка вперед."
        },
        "rebase x": {
            "cmd": "rebase <восходящая ветка>",
            "docs": "Отменить все коммиты с тех пор, как текущая ветка отклонилась от <восходящей ветки>, а затем повторно применить их один за другим поверх изменений из `HEAD` <восходящей ветки>."
        },
        "cherry-pick x": {
            "cmd": "cherry-pick <коммит>",
            "docs": "Интегрировать изменения указанного коммита в текущую ветку."
        },
        "revert x": {
            "cmd": "revert <коммит>",
            "docs": "Отменить указанный <коммит>, и закоммитить результат. Для этого необходимо, чтобы ваше рабочее дерево было чистым (без изменений после коммита `HEAD`)."
        },
        "diff --cached": {
            "cmd": "diff --cached [<коммит>]",
            "docs": "Просмотр изменений, которые вы внесли, по сравнению с последним коммитом. Можно передать <коммит>, чтобы увидеть изменения относительно него."
        },
        "commit": {
            "cmd": "commit [-m 'сообщение']",
            "docs": "Сохранить текущее содержимое индекса в новом коммите вместе с сообщением от пользователя, описывающим изменения."
        },
        "commit --amend": {
            "cmd": "commit --amend",
            "docs": "Изменить последний коммит с учётом текущих изменений индекса."
        },
        "log": {
            "cmd": "log",
            "docs": "Отобразить последние коммиты, самые последние вверху. Опции:\r`‑‑decorate` с именами веток и тегов на соответствующих коммитах\r`‑‑stat` со статистикой (изменения файлов, вставки и удаления) \r`‑‑author=<автор>` только определённого автора\r`‑‑after=\"МММ ДД ГГГГ\"` напр. (`Jun 20 2008`) только коммиты после определённой даты\r`‑-before=\"МММ ДД ГГГГ\"` только коммиты до определённой даты \r`‑‑merge` только те коммиты, которые включены в текущее объединение конфликтов."
        },
        "diff x x": {
            "cmd": "diff <коммит> <коммит>",
            "docs": "Отобразить изменений между двумя произвольными коммитами"
        },
        "branch": {
            "cmd": "branch",
            "docs": "Вывести все существующие ветки. Опция `-r` приводит к отображению веток удалённого репозитория, а опция `-a` показывает оба репозитория."
        },
        "branch -d x": {
            "cmd": "branch -d <ветка>",
            "docs": "Удалить указанную ветку. Укажите `-D` для принудительного выполнения."
        },
        "branch --track x x": {
            "cmd": "branch --track <название новой ветки> <удалённый репозиторий>/<ветка>",
            "docs": "Создать новую локальную ветку из ветки удалённого репозитория."
        },
        "clone x": {
            "cmd": "clone <репозиторий>",
            "docs": "Загрузить указанный <репозиторий>, и извлечь `HEAD` основной ветки."
        },
        "pull x x": {
            "cmd": "pull <удалённый репозиторий> <спецификация ссылки>",
            "docs": "Включить изменения из удалённого репозитория в текущую ветку. В режиме по умолчанию `git pull` является сокращением от `git fetch`, за которым следует `git merge FETCH_HEAD`."
        },
        "reset --hard x/x": {
            "cmd": "reset --hard <удалённый репозиторий>/<ветка>",
            "docs": "Сбросить локальный репозиторий и рабочее дерево, чтобы оно соответствовало ветке удалённого отслеживания. Используйте `reset ‑-hard origin/main`, чтобы отменить все коммиты в локальной основной ветке. Используйте это, чтобы начать заново в случае неудачного слияния."
        },
        "fetch x x": {
            "cmd": "fetch <удалённый репозиторий> <спецификация ссылки>",
            "docs": "Скачать объекты и ссылки из другого репозитория."
        },
        "push": {
            "cmd": "push",
            "docs": "Обновить сервер своими коммитами во всех ветках, которые являются *ОБЩИМИ* между вашей локальной копией и сервером. Локальные ветки, которые никогда не были отправлены на сервер, не являются общими."
        },
        "push x x": {
            "cmd": "push <удалённый репозиторий> <ветка>",
            "docs": "Отправить новую (или существующую) ветку в удалённый репозиторий."
        },
        "push x x:x": {
            "cmd": "push <удалённый репозиторий> <локальная ветка>:<имя>",
            "docs": "Отправить ветку в удалённый репозиторий с другим именем. <локальная ветка> — это имя локальной ветки, а <имя> — это имя ветки в удалённом репозитории."
        },
        "branch -r": {
            "cmd": "branch -r",
            "docs": "Вывести список удалённых веток"
        },
        "push --delete": {
            "cmd": "push <удалённый репозиторий> --delete <ветка>",
            "docs": "Удалить удалённую ветку."
        },
        "clean": {
            "cmd": "clean",
            "docs": "Очистить рабочее дерево, рекурсивно удаляя файлы, не находящиеся под контролем версий, начиная с текущего каталога. Используйте `-n` для «пробного прогона», чтобы увидеть, что будет удалено. Используйте `-f` для удаления файлов."
        },
        "stash push": {
            "cmd": "stash push [<сообщение>]",
            "docs": "Сохранить локальные изменения в новом тайнике и выполнить «git reset‑‑hard», чтобы отменить их. <сообщение> является необязательнвм и содержит описание к спрятанному состоянию. Чтобы быстро сделать снимок, вы можете опустить `push` и <сообщение>."
        },
        "stash apply": {
            "cmd": "stash apply [<тайник>]",
            "docs": "Переместить изменения из указанного тайника в рабочую область. Последний тайник используется по умолчанию."
        },
        "stash pop": {
            "cmd": "stash pop",
            "docs": "Применяет изменения из последнего (или указанного) тайника, а затем удаляет данный тайник."
        },
        "stash list": {
            "cmd": "stash list",
            "docs": "Вывести тайники, которые у вас есть на данный момент."
        },
        "stash show": {
            "cmd": "stash show [<тайник>]",
            "docs": "Показать изменения, записанные в тайнике, как разницу между спрятанным состоянием и его исходным родительским состоянием. Если <stash> не указан, отображается последний."
        },
        "stash drop": {
            "cmd": "stash drop [<тайник>]",
            "docs": "Удалить одно спрятанное состояние из списка спрятанного. Если <тайник> не указан, удаляется последний."
        },
        "stash clear": {
            "cmd": "stash clear",
            "docs": "Удалить все спрятанные состояния. Обратите внимание, что эти состояния затем будут подвергнуты очистке, и их будет невозможно восстановить."
        },
        "stash branch x": {
            "cmd": "stash branch <имя ветки> [<тайник>]",
            "docs": "Создать и извлечь новую ветку с именем <имя ветки>, начиная с коммита, в котором изначально был создан <тайник>, применяет изменения, записанные в <тайник>, к новому рабочему дереву и индексу. \rЕсли это удалось и <тайник> является ссылкой в ​​форме stash@{<ревизия>}, <тайник> удаляется. Если <тайник> не указан, применяется последний. \rЭто полезно, если ветка, в которой вы запустили `git stash push`, изменилась настолько, что `git stash apply` не работает из-за конфликтов. Поскольку кэш применяется поверх коммита, который был `HEAD` на момент запуска git stash, он восстанавливает исходное спрятанное состояние без конфликтов."
        }
    },
    "locations": {
        "stash": "тайник",
        "workspace": "рабочее пространство",
        "index": "индекс",
        "local_repo": "локальный репозиторий",
        "remote_repo": "вышестоящий (удалённый) репозиторий",
        "docs": {
            "stash": "Место, где можно спрятать изменения, пока вы работаете над чем-то другим.",
            "workspace": "Локальная копия вашего кода. Также называется «рабочей копией», «рабочим деревом» или просто «копия». Это любой каталог в вашей файловой системе, с которым связан репозиторий (обычно на это указывает наличие в нем подкаталога с именем `.git`). Он включает в себя все файлы и подкаталоги в этом каталоге.",
            "index": "Промежуточная область для фиксации изменений файла. Прежде чем «закоммитить» (или вернуть) файлы, вам необходимо сначала добавить их в индекс. Это также называется «кешем текущего каталога», «промежуточной областью», «кэшем» или «проиндексированными файлами».",
            "local_repo": "Каталог с именем `.git`, содержащий все необходимые файлы репозитория — скелет репозитория Git. Типичные ветки: `main`, `master`, `feature-x`, `bugfix-y`. Локальный репозиторий имеет те же функции и возможности, что и любой другой репозиторий Git.",
            "remote_repo": "Репозиторий вашего кода, которым можно делиться и работать совместно с другими разработчиками. Он размещён в Интернете или на удалённом компьютере, например github. Имя по умолчанию — «origin». Типичные ветки здесь: `main`, `master`, `shared-feature-x`, `release-y`. Также называется «удаленным репозиторием» или просто «удалённым»."
        }
    }
}
